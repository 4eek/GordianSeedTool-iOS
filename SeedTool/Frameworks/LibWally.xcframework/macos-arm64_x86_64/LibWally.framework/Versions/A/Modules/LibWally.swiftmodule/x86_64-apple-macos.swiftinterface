// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
// swift-module-flags: -target x86_64-apple-macos11 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name LibWally
import Foundation
@_exported import LibWally
import Security
import Swift
public typealias PrivateKeyProvider = (LibWally.HDKey) -> LibWally.HDKey?
public struct Descriptor {
  public let source: Swift.String
  public init(_ source: Swift.String) throws
  public func scriptPubKey(wildcardChildNum: Swift.UInt32? = nil, privateKeyProvider: LibWally.PrivateKeyProvider? = nil, comboOutput: LibWally.Descriptor.ComboOutput? = nil) -> LibWally.ScriptPubKey?
  public var isCombo: Swift.Bool {
    get
  }
  public enum ComboOutput {
    case pk
    case pkh
    case wpkh
    case sh_wpkh
    public static func == (a: LibWally.Descriptor.ComboOutput, b: LibWally.Descriptor.ComboOutput) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var requiresWildcardChildNum: Swift.Bool {
    get
  }
}
extension LibWally.Descriptor : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct PSBTInput {
  public let origins: [LibWally.PSBTSigningOrigin]
  public let signatures: [LibWally.ECCompressedPublicKey : Foundation.Data]
  public let witnessScript: LibWally.ScriptPubKey?
  public let isSegwit: Swift.Bool
  public let amount: LibWally.Satoshi?
  public func signableOrigins(with masterKey: LibWally.HDKey) -> [LibWally.PSBTSigningOrigin]
  public func canSign(with masterKey: LibWally.HDKey) -> Swift.Bool
  public func originsSigned(by masterKey: LibWally.HDKey) -> [LibWally.PSBTSigningOrigin]
  public func isSigned(by masterKey: LibWally.HDKey) -> Swift.Bool
  public func address(network: LibWally.Network) -> Swift.String?
  public var isFullySigned: Swift.Bool {
    get
  }
}
extension LibWally.PSBTInput : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.PSBTInput {
  public func signingStatus<SignerType>(signers: [SignerType]) -> [LibWally.PSBTSigningStatus<SignerType>] where SignerType : LibWally.PSBTSigner
}
public struct Transaction {
  public let inputs: [LibWally.TxInput]?
  public let outputs: [LibWally.TxOutput]?
  public init?(hex: Swift.String)
  public init(inputs: [LibWally.TxInput], outputs: [LibWally.TxOutput])
  public var vbytes: Swift.Int? {
    get
  }
  public var fee: LibWally.Satoshi? {
    get
  }
  public var feeRate: Swift.Float64? {
    get
  }
  public func signed(with privKeys: [LibWally.HDKey]) -> LibWally.Transaction?
}
extension LibWally.Transaction : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol ECKey {
  static var keyLen: Swift.Int { get }
  var data: Foundation.Data { get }
  init?(_ data: Foundation.Data)
  var hex: Swift.String { get }
  var `public`: LibWally.ECCompressedPublicKey { get }
}
extension LibWally.ECKey {
  public var hex: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
public protocol ECPublicKey : LibWally.ECKey {
  var compressed: LibWally.ECCompressedPublicKey { get }
  var uncompressed: LibWally.ECUncompressedPublicKey { get }
}
public struct ECPrivateKey : LibWally.ECKey {
  public static var keyLen: Swift.Int
  public let data: Foundation.Data
  public init?(_ data: Foundation.Data)
  public init?(hex: Swift.String)
  public var `public`: LibWally.ECCompressedPublicKey {
    get
  }
  public var wif: Swift.String {
    get
  }
}
extension LibWally.ECPrivateKey : Swift.CustomStringConvertible {
}
public struct ECXOnlyPublicKey : Swift.Hashable {
  public static var keyLen: Swift.Int
  public let data: Foundation.Data
  public init?(_ data: Foundation.Data)
  public init?(hex: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LibWally.ECXOnlyPublicKey, b: LibWally.ECXOnlyPublicKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct ECCompressedPublicKey : LibWally.ECPublicKey, Swift.Hashable {
  public static var keyLen: Swift.Int
  public let data: Foundation.Data
  public init?(_ data: Foundation.Data)
  public init?(hex: Swift.String)
  public var compressed: LibWally.ECCompressedPublicKey {
    get
  }
  public var uncompressed: LibWally.ECUncompressedPublicKey {
    get
  }
  public func address(version: Swift.UInt8) -> Swift.String
  public func address(useInfo: LibWally.UseInfo, isSH: Swift.Bool) -> Swift.String
  public var `public`: LibWally.ECCompressedPublicKey {
    get
  }
  public var hash160: Foundation.Data {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: LibWally.ECCompressedPublicKey, b: LibWally.ECCompressedPublicKey) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension LibWally.ECCompressedPublicKey : Swift.CustomStringConvertible {
}
public struct ECUncompressedPublicKey : LibWally.ECPublicKey {
  public static var keyLen: Swift.Int
  public let data: Foundation.Data
  public init?(_ data: Foundation.Data)
  public init?(hex: Swift.String)
  public var compressed: LibWally.ECCompressedPublicKey {
    get
  }
  public var uncompressed: LibWally.ECUncompressedPublicKey {
    get
  }
  public var `public`: LibWally.ECCompressedPublicKey {
    get
  }
}
extension LibWally.ECUncompressedPublicKey : Swift.CustomStringConvertible {
}
public enum Asset : Swift.UInt32, Swift.CaseIterable, Swift.Equatable {
  case btc
  case eth
  public init?(rawValue: Swift.UInt32)
  public typealias AllCases = [LibWally.Asset]
  public typealias RawValue = Swift.UInt32
  public static var allCases: [LibWally.Asset] {
    get
  }
  public var rawValue: Swift.UInt32 {
    get
  }
}
extension LibWally.Asset {
  public var coinType: Swift.UInt32 {
    get
  }
}
extension LibWally.Asset : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension LibWally.Asset {
  public init?(_ symbol: Swift.String)
  public var symbol: Swift.String {
    get
  }
}
extension LibWally.Asset {
  public var name: Swift.String {
    get
  }
}
extension LibWally.Asset : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public func deterministicRandom(entropy: Foundation.Data, count: Swift.Int) -> Foundation.Data
public enum Wally {
}
extension LibWally.Wally {
  public static func key(from parentKey: LibWally.WallyExtKey, childNum: Swift.UInt32, isPrivate: Swift.Bool) -> LibWally.WallyExtKey?
  public static func fingerprintData(for key: LibWally.WallyExtKey) -> Foundation.Data
  public static func fingerprint(for key: LibWally.WallyExtKey) -> Swift.UInt32
  public static func updateHash160(in key: inout LibWally.WallyExtKey)
  public static func updatePublicKey(in key: inout LibWally.WallyExtKey)
}
extension LibWally.Wally {
  public static func ecPublicKeyFromPrivateKey(data: Foundation.Data) -> Foundation.Data
  public static func ecPublicKeyDecompress(data: Foundation.Data) -> Foundation.Data
  public static func ecPublicKeyCompress(data: Foundation.Data) -> Foundation.Data
  public static func hash160(_ data: Foundation.Data) -> Foundation.Data
  public static func hash160<T>(_ input: T) -> Foundation.Data
}
extension LibWally.Wally {
  public static func hdKey(bip39Seed seed: LibWally.BIP39.Seed, network: LibWally.Network) -> LibWally.WallyExtKey?
}
extension LibWally.Wally {
  public static func ecPrivateKeyVerify(_ privKey: Foundation.Data) -> Swift.Bool
  public static func ecSigFromBytes(privKey: Foundation.Data, messageHash: Foundation.Data) -> Foundation.Data
  public static func ecSigVerify(key: LibWally.WallyExtKey, messageHash: Foundation.Data, compactSig: Foundation.Data) -> Swift.Bool
  public static func ecSigNormalize(compactSig: Foundation.Data) -> Foundation.Data
  public static func ecSigToDer(sigNorm: Foundation.Data) -> Foundation.Data
}
extension LibWally.Wally {
  public static func bip39Encode(data: Foundation.Data) -> Swift.String
  public static func bip39Decode(mnemonic: Swift.String) -> Foundation.Data?
  public static func bip39AllWords() -> [Swift.String]
}
extension Foundation.Data {
  public var hash160: Foundation.Data {
    get
  }
}
extension LibWally.ext_key : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  public var isPrivate: Swift.Bool {
    get
  }
  public var keyType: LibWally.KeyType {
    get
  }
  public var isMaster: Swift.Bool {
    get
  }
  public static func version_is_valid(ver: Swift.UInt32, flags: Swift.UInt32) -> Swift.Bool
  public func checkValid()
  public var network: LibWally.Network? {
    get
  }
}
extension Foundation.Data {
  public var keccak256: Foundation.Data {
    get
  }
}
public struct PSBT : Swift.Equatable {
  public let inputs: [LibWally.PSBTInput]
  public let outputs: [LibWally.PSBTOutput]
  public static func == (lhs: LibWally.PSBT, rhs: LibWally.PSBT) -> Swift.Bool
  public init?(_ data: Foundation.Data)
  public init?(base64 string: Swift.String)
  public init?(hex: Swift.String)
  public var data: Foundation.Data {
    get
  }
  public var base64: Swift.String {
    get
  }
  public var hex: Swift.String {
    get
  }
  public var isFinalized: Swift.Bool {
    get
  }
  public var transaction: LibWally.Transaction {
    get
  }
  public var totalIn: LibWally.Satoshi? {
    get
  }
  public var totalOut: LibWally.Satoshi? {
    get
  }
  public var fee: LibWally.Satoshi? {
    get
  }
  public var totalChange: LibWally.Satoshi? {
    get
  }
  public var totalSent: LibWally.Satoshi? {
    get
  }
  public func finalizedTransaction() -> LibWally.Transaction?
  public func signed(with privKey: LibWally.ECPrivateKey) -> LibWally.PSBT?
  public func signed(with hdKey: LibWally.HDKey) -> LibWally.PSBT?
  public func signed<SignerType>(with signer: SignerType) -> LibWally.PSBT? where SignerType : LibWally.PSBTSigner
  public func signed<SignerType>(with inputSigning: [LibWally.PSBTInputSigning<SignerType>]) -> LibWally.PSBT? where SignerType : LibWally.PSBTSigner
  public func finalized() -> LibWally.PSBT?
  public var isFullySigned: Swift.Bool {
    get
  }
}
extension LibWally.PSBT : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct PSBTInputSigning<SignerType> : Swift.Identifiable where SignerType : LibWally.PSBTSigner {
  public let id: Foundation.UUID
  public let input: LibWally.PSBTInput
  public let statuses: [LibWally.PSBTSigningStatus<SignerType>]
  public typealias ID = Foundation.UUID
}
public struct PSBTOutputSigning<SignerType> : Swift.Identifiable where SignerType : LibWally.PSBTSigner {
  public let id: Foundation.UUID
  public let output: LibWally.PSBTOutput
  public let statuses: [LibWally.PSBTSigningStatus<SignerType>]
  public typealias ID = Foundation.UUID
}
extension LibWally.PSBT {
  public func inputSigning<SignerType>(signers: [SignerType]) -> [LibWally.PSBTInputSigning<SignerType>] where SignerType : LibWally.PSBTSigner
  public func outputSigning<SignerType>(signers: [SignerType]) -> [LibWally.PSBTOutputSigning<SignerType>] where SignerType : LibWally.PSBTSigner
  public static func countOfSignableInputs<SignerType>(for signings: [LibWally.PSBTInputSigning<SignerType>]) -> Swift.Int where SignerType : LibWally.PSBTSigner
  public static func countOfUniqueSigners<SignerType>(for signings: [LibWally.PSBTInputSigning<SignerType>]) -> Swift.Int where SignerType : LibWally.PSBTSigner
}
public struct PSBTSigningStatus<SignerType> : Swift.Identifiable where SignerType : LibWally.PSBTSigner {
  public let id: Foundation.UUID
  public let origin: LibWally.PSBTSigningOrigin
  public let isSigned: Swift.Bool
  public let knownSigner: SignerType?
  public enum Status {
    case isSignedBy(SignerType)
    case isSignedByUnknown
    case canBeSignedBy(SignerType)
    case noKnownSigner
  }
  public var status: LibWally.PSBTSigningStatus<SignerType>.Status {
    get
  }
  public var canBeSigned: Swift.Bool {
    get
  }
  public typealias ID = Foundation.UUID
}
public enum ChildIndexSpec : Swift.Equatable {
  case index(LibWally.ChildIndex)
  case indexRange(LibWally.ChildIndexRange)
  case indexWildcard
  public var isFixed: Swift.Bool {
    get
  }
  public static func == (a: LibWally.ChildIndexSpec, b: LibWally.ChildIndexSpec) -> Swift.Bool
}
extension LibWally.ChildIndexSpec : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.ChildIndexSpec {
  public static func parse(_ s: Swift.String) -> LibWally.ChildIndexSpec?
}
@frozen public enum KeyType : Swift.Identifiable, Swift.CaseIterable {
  case `private`
  case `public`
  public var id: Swift.String {
    get
  }
  public var name: Swift.String {
    get
  }
  public var isPrivate: Swift.Bool {
    get
  }
  public init(isPrivate: Swift.Bool)
  public static func == (a: LibWally.KeyType, b: LibWally.KeyType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [LibWally.KeyType]
  public typealias ID = Swift.String
  public static var allCases: [LibWally.KeyType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum Network : Swift.UInt32, Swift.CaseIterable, Swift.Equatable {
  case mainnet
  case testnet
  public init?(rawValue: Swift.UInt32)
  public typealias AllCases = [LibWally.Network]
  public typealias RawValue = Swift.UInt32
  public static var allCases: [LibWally.Network] {
    get
  }
  public var rawValue: Swift.UInt32 {
    get
  }
}
extension LibWally.Network : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public typealias ID = Swift.String
}
extension LibWally.Network : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.Network {
  public var wifPrefix: Swift.UInt32 {
    get
  }
  public static func network(forWIFPrefix prefix: Swift.UInt8) -> LibWally.Network?
}
extension LibWally.Network {
  public var segwitFamily: Swift.String {
    get
  }
}
extension LibWally.Network {
  public var wallyNetwork: Swift.UInt32 {
    get
  }
}
extension LibWally.Network {
  public func wallyBIP32Version(isPrivate: Swift.Bool) -> Swift.UInt32
}
public enum Ethereum {
}
public struct ChildIndex : Swift.ExpressibleByIntegerLiteral, Swift.Comparable {
  public let value: Swift.UInt32
  public init?(_ value: Swift.UInt32)
  public init(integerLiteral value: Swift.UInt32)
  public static func == (lhs: LibWally.ChildIndex, rhs: LibWally.ChildIndex) -> Swift.Bool
  public static func < (lhs: LibWally.ChildIndex, rhs: LibWally.ChildIndex) -> Swift.Bool
  public typealias IntegerLiteralType = Swift.UInt32
}
extension LibWally.ChildIndex : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Swift.String {
  public init(_ index: LibWally.ChildIndex)
}
extension LibWally.ChildIndex {
  public static func parse(_ s: Swift.String) -> LibWally.ChildIndex?
}
extension LibWally.Account {
  public var ethereumAddress: LibWally.Ethereum.Address? {
    get
  }
}
open class Seed {
  final public let data: Foundation.Data
  public init?(data: Foundation.Data)
  public convenience init?(hex: Swift.String)
  public init(_ seed: LibWally.Seed)
  public convenience init()
  @objc deinit
}
extension LibWally.Seed {
  public var hex: Swift.String {
    get
  }
}
extension LibWally.Seed {
  public var bip39: LibWally.BIP39 {
    get
  }
  public convenience init(bip39: LibWally.BIP39)
}
public struct DerivationPath : Swift.Equatable {
  public var origin: LibWally.DerivationPath.Origin?
  public var steps: [LibWally.DerivationStep]
  public var depth: Swift.Int?
  public var isMaster: Swift.Bool {
    get
  }
  public enum Origin : Swift.Equatable, Swift.CustomStringConvertible {
    case fingerprint(Swift.UInt32)
    case master
    public var description: Swift.String {
      get
    }
    public static func == (a: LibWally.DerivationPath.Origin, b: LibWally.DerivationPath.Origin) -> Swift.Bool
  }
  public init()
  public init(steps: [LibWally.DerivationStep], origin: LibWally.DerivationPath.Origin? = nil, depth: Swift.Int? = nil)
  public init?(rawPath: [Swift.UInt32], origin: LibWally.DerivationPath.Origin? = nil, depth: Swift.Int? = nil)
  public init(origin: LibWally.DerivationPath.Origin?, depth: Swift.Int? = nil)
  public init(step: LibWally.DerivationStep, origin: LibWally.DerivationPath.Origin? = nil, depth: Swift.Int? = nil)
  public init(index: LibWally.ChildIndex, origin: LibWally.DerivationPath.Origin? = nil, depth: Swift.Int? = nil)
  public init(originFingerprint: Swift.UInt32, depth: Swift.Int? = nil)
  public init?(string: Swift.String, requireFixed: Swift.Bool = false)
  public var originFingerprint: Swift.UInt32? {
    get
    set(newValue)
  }
  public var effectiveDepth: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var hasWildcard: Swift.Bool {
    get
  }
  public func rawPath(wildcardChildNum: Swift.UInt32? = nil) -> [Swift.UInt32?]
  public func dropFirst(_ k: Swift.Int) -> LibWally.DerivationPath?
  public func toString(format: LibWally.DerivationStepFormat = .tickMark) -> Swift.String
  public static func == (a: LibWally.DerivationPath, b: LibWally.DerivationPath) -> Swift.Bool
}
extension LibWally.DerivationPath {
  public var isBIP44: Swift.Bool {
    get
  }
  public var isBIP48: Swift.Bool {
    get
  }
  public var isBIP44Change: Swift.Bool {
    get
  }
  public var isBIP48Change: Swift.Bool {
    get
  }
  public var isChange: Swift.Bool {
    get
  }
}
extension LibWally.DerivationPath : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: LibWally.DerivationStep...)
  public typealias ArrayLiteralElement = LibWally.DerivationStep
}
extension LibWally.DerivationPath : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.DerivationPath {
  public static func + (lhs: LibWally.DerivationPath, rhs: LibWally.DerivationPath) -> LibWally.DerivationPath
}
public enum ScriptOperation : Swift.Equatable {
  case data(Foundation.Data)
  case op(LibWally.ScriptOpcode)
  public init(_ data: Foundation.Data)
  public init(_ opcode: LibWally.ScriptOpcode)
  public init?(_ string: Swift.String)
  public var serialized: Foundation.Data {
    get
  }
  public static func == (a: LibWally.ScriptOperation, b: LibWally.ScriptOperation) -> Swift.Bool
}
extension LibWally.ScriptOperation : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.ScriptOperation {
  public var intValue: Swift.Int? {
    get
  }
}
public struct WIF : Swift.CustomStringConvertible {
  public let key: LibWally.ECPrivateKey
  public let network: LibWally.Network
  public let isPublicKeyCompressed: Swift.Bool
  public init(key: LibWally.ECPrivateKey, network: LibWally.Network, isPublicKeyCompressed: Swift.Bool = true)
  public init?(_ wif: Swift.String)
  public var description: Swift.String {
    get
  }
}
public struct ChildIndexRange : Swift.Equatable {
  public let low: LibWally.ChildIndex
  public let high: LibWally.ChildIndex
  public init?(low: LibWally.ChildIndex, high: LibWally.ChildIndex)
  public static func == (a: LibWally.ChildIndexRange, b: LibWally.ChildIndexRange) -> Swift.Bool
}
extension LibWally.ChildIndexRange : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.ChildIndexRange {
  public static func parse(_ s: Swift.String) -> LibWally.ChildIndexRange?
}
public struct ScriptPubKey : Swift.Equatable {
  public let script: LibWally.Script
  public enum ScriptType {
    case `return`
    case pk
    case pkh
    case sh
    case wpkh
    case wsh
    case multi
    public static func == (a: LibWally.ScriptPubKey.ScriptType, b: LibWally.ScriptPubKey.ScriptType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var type: LibWally.ScriptPubKey.ScriptType? {
    get
  }
  public init?(hex: Swift.String)
  public init(multisig pubKeys: [LibWally.ECCompressedPublicKey], threshold: Swift.UInt, isBIP67: Swift.Bool = true)
  public init(_ script: LibWally.Script)
  public var witnessProgram: LibWally.Script {
    get
  }
  public var hex: Swift.String {
    get
  }
  public var asm: Swift.String? {
    get
  }
  public var multisigInfo: (Swift.Int, Swift.Int)? {
    get
  }
  public static func == (a: LibWally.ScriptPubKey, b: LibWally.ScriptPubKey) -> Swift.Bool
}
extension LibWally.ScriptPubKey : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum Bitcoin {
}
public typealias Satoshi = Swift.UInt64
public func formatBTC(_ satoshi: LibWally.Satoshi) -> Swift.String
extension Swift.UInt64 {
  public var btcFormat: Swift.String {
    get
  }
}
public struct VarInt {
  public let value: Swift.Int
  public init?(_ value: Swift.Int)
  public init?<D>(_ data: D) where D : Foundation.DataProtocol
  public var serializedSize: Swift.Int {
    get
  }
  public var serialized: Foundation.Data {
    get
  }
}
extension LibWally.VarInt : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension LibWally.VarInt : Swift.Comparable {
  public static func < (lhs: LibWally.VarInt, rhs: LibWally.VarInt) -> Swift.Bool
}
extension LibWally.VarInt : Swift.Equatable {
  public static func == (lhs: LibWally.VarInt, rhs: LibWally.VarInt) -> Swift.Bool
}
open class Account {
  final public let useInfo: LibWally.UseInfo
  final public let account: Swift.UInt32?
  final public let seed: LibWally.Seed?
  public var accountPath: LibWally.DerivationPath {
    get
  }
  public var bip39Seed: LibWally.BIP39.Seed? {
    get
  }
  public var masterKey: LibWally.HDKey? {
    get
  }
  public var accountKey: LibWally.HDKey? {
    get
  }
  public var accountECPrivateKey: LibWally.ECPrivateKey? {
    get
  }
  public var accountECPublicKey: LibWally.ECPublicKey? {
    get
  }
  public init(seed: LibWally.Seed, useInfo: LibWally.UseInfo, account: Swift.UInt32)
  public convenience init?(mnemonic: Swift.String, useInfo: LibWally.UseInfo, account: Swift.UInt32)
  public init(bip39Seed: LibWally.BIP39.Seed, useInfo: LibWally.UseInfo, account: Swift.UInt32)
  public init(masterKey: LibWally.HDKey, useInfo: LibWally.UseInfo, account: Swift.UInt32)
  public init(accountKey: LibWally.HDKey, useInfo: LibWally.UseInfo)
  @objc deinit
}
public typealias WallyTx = Swift.UnsafeMutablePointer<LibWally.wally_tx>
public typealias WallyTxInput = Swift.UnsafeMutablePointer<LibWally.wally_tx_input>
public typealias WallyTxOutput = Swift.UnsafeMutablePointer<LibWally.wally_tx_output>
public typealias WallyExtKey = LibWally.ext_key
public typealias WallyPSBT = Swift.UnsafeMutablePointer<LibWally.wally_psbt>
public typealias WallyPSBTInput = LibWally.wally_psbt_input
public typealias WallyPSBTOutput = LibWally.wally_psbt_output
extension LibWally.Wally {
  public static func base58(from key: LibWally.WallyExtKey, isPrivate: Swift.Bool) -> Swift.String?
  public static func base58(data: Foundation.Data, isCheck: Swift.Bool) -> Swift.String
  public static func decodeBase58(_ s: Swift.String, isCheck: Swift.Bool) -> Foundation.Data?
}
extension LibWally.Wally {
  public static func hdKeyToAddress(hdKey: LibWally.HDKey, type: LibWally.Bitcoin.Address.AddressType) -> Swift.String
}
extension LibWally.Wally {
  public static func encodeWIF(key: LibWally.ECPrivateKey, network: LibWally.Network, isPublicKeyCompressed: Swift.Bool) -> Swift.String
}
extension LibWally.Wally {
  public static func psbt(from data: Foundation.Data) -> LibWally.WallyPSBT?
  public static func free(psbt: LibWally.WallyPSBT)
  public static func clone(psbt: LibWally.WallyPSBT) -> LibWally.WallyPSBT
  public static func isFinalized(psbt: LibWally.WallyPSBT) -> Swift.Bool
  public static func finalized(psbt: LibWally.WallyPSBT) -> LibWally.WallyPSBT?
  public static func finalizedTransaction(psbt: LibWally.WallyPSBT) -> LibWally.Transaction?
  public static func getLength(psbt: LibWally.WallyPSBT) -> Swift.Int
  public static func serialized(psbt: LibWally.WallyPSBT) -> Foundation.Data
  public static func signed(psbt: LibWally.WallyPSBT, ecPrivateKey: Foundation.Data) -> LibWally.WallyPSBT?
}
extension LibWally.Wally {
  public static func getType(from scriptPubKey: LibWally.ScriptPubKey) -> LibWally.ScriptPubKey.ScriptType?
  public static func multisigScriptPubKey(pubKeys: [LibWally.ECCompressedPublicKey], threshold: Swift.UInt, isBIP67: Swift.Bool = true) -> LibWally.ScriptPubKey
  public static func address(from scriptPubKey: LibWally.ScriptPubKey, network: LibWally.Network) -> Swift.String
  public static func segwitAddress(script: LibWally.Script, network: LibWally.Network) -> Swift.String
  public static func segwitAddress(scriptPubKey: LibWally.ScriptPubKey, network: LibWally.Network) -> Swift.String
  public static func witnessProgram(scriptPubKey: LibWally.ScriptPubKey) -> LibWally.Script
  public static func addressToScriptPubKey(address: Swift.String, network: LibWally.Network) -> LibWally.ScriptPubKey?
  public static func segwitAddressToScriptPubKey(address: Swift.String, network: LibWally.Network) -> LibWally.ScriptPubKey?
  public static func hdKey(fromBase58 base58: Swift.String) -> LibWally.WallyExtKey?
}
extension LibWally.Wally {
  public static func txFromBytes(_ data: Foundation.Data) -> LibWally.WallyTx?
  public static func txSetInputScript(tx: LibWally.WallyTx, index: Swift.Int, script: Foundation.Data)
  public static func txAddInput(tx: LibWally.WallyTx, input: LibWally.WallyTxInput)
  public static func txAddOutput(tx: LibWally.WallyTx, output: LibWally.WallyTxOutput)
  public static func txToHex(tx: LibWally.WallyTx) -> Swift.String
  public static func txGetTotalOutputSatoshi(tx: LibWally.WallyTx) -> LibWally.Satoshi
  public static func txGetVsize(tx: LibWally.WallyTx) -> Swift.Int
  public static func txGetBTCSignatureHash(tx: LibWally.WallyTx, index: Swift.Int, script: Foundation.Data, amount: LibWally.Satoshi, isWitness: Swift.Bool) -> Foundation.Data
}
extension Foundation.Data {
  public func base58(isCheck: Swift.Bool) -> Swift.String
}
public protocol AddressProtocol : Swift.CustomStringConvertible {
  var useInfo: LibWally.UseInfo { get }
  var string: Swift.String { get }
}
public enum ScriptOpcode : Swift.UInt8, Swift.Equatable {
  case op_0
  case op_pushdata1
  case op_pushdata2
  case op_pushdata4
  case op_1negate
  case op_reserved
  case op_1
  case op_2
  case op_3
  case op_4
  case op_5
  case op_6
  case op_7
  case op_8
  case op_9
  case op_10
  case op_11
  case op_12
  case op_13
  case op_14
  case op_15
  case op_16
  case op_nop
  case op_ver
  case op_if
  case op_notif
  case op_verif
  case op_vernotif
  case op_else
  case op_endif
  case op_verify
  case op_return
  case op_toaltstack
  case op_fromaltstack
  case op_2drop
  case op_2dup
  case op_3dup
  case op_2over
  case op_2rot
  case op_2swap
  case op_ifdup
  case op_depth
  case op_drop
  case op_dup
  case op_nip
  case op_over
  case op_pick
  case op_roll
  case op_rot
  case op_swap
  case op_tuck
  case op_cat
  case op_substr
  case op_left
  case op_right
  case op_size
  case op_invert
  case op_and
  case op_or
  case op_xor
  case op_equal
  case op_equalverify
  case op_reserved1
  case op_reserved2
  case op_1add
  case op_1sub
  case op_2mul
  case op_2div
  case op_negate
  case op_abs
  case op_not
  case op_0notequal
  case op_add
  case op_sub
  case op_mul
  case op_div
  case op_mod
  case op_lshift
  case op_rshift
  case op_booland
  case op_boolor
  case op_numequal
  case op_numequalverify
  case op_numnotequal
  case op_lessthan
  case op_greaterthan
  case op_lessthanorequal
  case op_greaterthanorequal
  case op_min
  case op_max
  case op_within
  case op_ripemd160
  case op_sha1
  case op_sha256
  case op_hash160
  case op_hash256
  case op_codeseparator
  case op_checksig
  case op_checksigverify
  case op_checkmultisig
  case op_checkmultisigverify
  case op_nop1
  case op_checklocktimeverify
  case op_checksequenceverify
  case op_nop4
  case op_nop5
  case op_nop6
  case op_nop7
  case op_nop8
  case op_nop9
  case op_nop10
  case op_checksigadd
  case op_invalidopcode
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
extension LibWally.ScriptOpcode {
  public init?(int i: Swift.Int)
}
extension LibWally.ScriptOpcode {
  public var intValue: Swift.Int? {
    get
  }
}
extension LibWally.ScriptOpcode : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.ScriptOpcode {
  public init?(name: Swift.String)
  public var name: Swift.String? {
    get
  }
}
public struct PSBTOutput {
  public let txOutput: LibWally.TxOutput
  public let origins: [LibWally.PSBTSigningOrigin]
  public func address(network: LibWally.Network) -> Swift.String
  public var amount: LibWally.Satoshi {
    get
  }
  public var isChange: Swift.Bool {
    get
  }
  public func isChange(signer: LibWally.HDKey, inputs: [LibWally.PSBTInput], cosigners: [LibWally.HDKey], threshold: Swift.UInt) -> Swift.Bool
}
extension LibWally.PSBTOutput {
  public func signingStatus<SignerType>(origin: LibWally.PSBTSigningOrigin, signers: [SignerType]) -> LibWally.PSBTSigningStatus<SignerType> where SignerType : LibWally.PSBTSigner
  public func signingStatus<SignerType>(signers: [SignerType]) -> [LibWally.PSBTSigningStatus<SignerType>] where SignerType : LibWally.PSBTSigner
}
public struct DerivationStep : Swift.Equatable {
  public let childIndexSpec: LibWally.ChildIndexSpec
  public let isHardened: Swift.Bool
  public var isWildcard: Swift.Bool {
    get
  }
  public init(_ childIndexSpec: LibWally.ChildIndexSpec, isHardened: Swift.Bool = false)
  public init(_ index: LibWally.ChildIndex, isHardened: Swift.Bool = false)
  public init(rawValue: Swift.UInt32)
  public init?(string: Swift.String)
  public func rawValue(wildcardChildNum: Swift.UInt32? = nil) -> Swift.UInt32?
  public func toString(format: LibWally.DerivationStepFormat = .tickMark) -> Swift.String
  public static func == (a: LibWally.DerivationStep, b: LibWally.DerivationStep) -> Swift.Bool
}
extension LibWally.DerivationStep : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
public enum DerivationStepFormat {
  case tickMark
  case letter
  public var string: Swift.String {
    get
  }
  public static func == (a: LibWally.DerivationStepFormat, b: LibWally.DerivationStepFormat) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension LibWally.DerivationStep : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct TxOutput {
  public let scriptPubKey: LibWally.ScriptPubKey
  public var amount: LibWally.Satoshi
  public func address(network: LibWally.Network) -> Swift.String
  public init(scriptPubKey: LibWally.ScriptPubKey, amount: LibWally.Satoshi)
  public func createWallyOutput() -> LibWally.WallyTxOutput
}
extension LibWally.TxOutput : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.Account {
  public func bitcoinAddress(type: LibWally.Bitcoin.Address.AddressType) -> LibWally.Bitcoin.Address?
}
open class HDKey {
  final public let isMaster: Swift.Bool
  final public let keyType: LibWally.KeyType
  final public let keyData: Foundation.Data
  final public let chainCode: Foundation.Data?
  final public let useInfo: LibWally.UseInfo
  final public let parent: LibWally.DerivationPath
  final public let children: LibWally.DerivationPath
  final public let parentFingerprint: Swift.UInt32?
  public enum Error : Swift.Error {
    case invalidSeed
    case invalidBase58
    case cannotDerivePrivateFromPublic
    case cannotDeriveHardenedFromPublic
    case cannotDeriveFromNonDerivable
    case cannotDeriveInspecificStep
    case invalidDepth
    case unknownDerivationError
    public static func == (a: LibWally.HDKey.Error, b: LibWally.HDKey.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(isMaster: Swift.Bool, keyType: LibWally.KeyType, keyData: Foundation.Data, chainCode: Foundation.Data?, useInfo: LibWally.UseInfo, parent: LibWally.DerivationPath?, children: LibWally.DerivationPath?, parentFingerprint: Swift.UInt32?)
  public init(_ key: LibWally.HDKey)
  public convenience init(key: LibWally.HDKey, derivedKeyType: LibWally.KeyType? = nil, isDerivable: Swift.Bool = true, parent: LibWally.DerivationPath? = nil, children: LibWally.DerivationPath? = nil) throws
  public convenience init(wallyExtKey key: LibWally.WallyExtKey, useInfo: LibWally.UseInfo? = nil, parent: LibWally.DerivationPath? = nil, children: LibWally.DerivationPath? = nil) throws
  public convenience init(base58: Swift.String, useInfo: LibWally.UseInfo? = nil, parent: LibWally.DerivationPath? = nil, children: LibWally.DerivationPath? = nil, overrideOriginFingerprint: Swift.UInt32? = nil) throws
  public convenience init(bip39Seed: LibWally.BIP39.Seed, useInfo: LibWally.UseInfo? = nil, parent: LibWally.DerivationPath? = nil, children: LibWally.DerivationPath? = nil) throws
  public convenience init(seed: LibWally.Seed, useInfo: LibWally.UseInfo? = nil, parent: LibWally.DerivationPath? = nil, children: LibWally.DerivationPath? = nil) throws
  public convenience init(parent: LibWally.HDKey, derivedKeyType: LibWally.KeyType? = nil, childDerivation: LibWally.DerivationStep, wildcardChildNum: Swift.UInt32? = nil) throws
  public convenience init(parent: LibWally.HDKey, derivedKeyType: LibWally.KeyType? = nil, childDerivationPath: LibWally.DerivationPath, isDerivable: Swift.Bool = true, wildcardChildNum: Swift.UInt32? = nil, privateKeyProvider: LibWally.PrivateKeyProvider? = nil, children: LibWally.DerivationPath? = nil) throws
  public var isPrivate: Swift.Bool {
    get
  }
  public var isDerivable: Swift.Bool {
    get
  }
  public var requiresWildcardChildNum: Swift.Bool {
    get
  }
  public var originFingerprint: Swift.UInt32? {
    get
  }
  public var keyFingerprintData: Foundation.Data {
    get
  }
  public var keyFingerprint: Swift.UInt32 {
    get
  }
  public var `public`: LibWally.HDKey {
    get
  }
  public var base58: Swift.String {
    get
  }
  public var base58PublicKey: Swift.String? {
    get
  }
  public var base58PrivateKey: Swift.String? {
    get
  }
  public var ecPublicKey: LibWally.ECCompressedPublicKey {
    get
  }
  public var ecPrivateKey: LibWally.ECPrivateKey? {
    get
  }
  public var wallyExtKey: LibWally.ext_key {
    get
  }
  public func description(withParent: Swift.Bool = false, withChildren: Swift.Bool = false) -> Swift.String
  public var fullDescription: Swift.String {
    get
  }
  @objc deinit
}
public struct PSBTSigningOrigin : Swift.CustomStringConvertible {
  public let key: LibWally.ECCompressedPublicKey
  public let path: LibWally.DerivationPath
  public var description: Swift.String {
    get
  }
  public func childKey(for masterKey: LibWally.HDKey) -> LibWally.ECCompressedPublicKey?
  public func canSign(with masterKey: LibWally.HDKey) -> Swift.Bool
  public var isChange: Swift.Bool {
    get
  }
}
extension LibWally.PSBTSigningOrigin {
  public func signingStatus<SignerType>(seeds: [SignerType], signatures: Swift.Set<LibWally.ECCompressedPublicKey>) -> LibWally.PSBTSigningStatus<SignerType> where SignerType : LibWally.PSBTSigner
}
public struct Witness {
  public let type: LibWally.Witness.WitnessType
  public let pubKey: LibWally.ECCompressedPublicKey
  public let signature: Foundation.Data
  public let isDummy: Swift.Bool
  public enum WitnessType {
    case payToWitnessPubKeyHash
    case payToScriptHashPayToWitnessPubKeyHash
    public static func == (a: LibWally.Witness.WitnessType, b: LibWally.Witness.WitnessType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(type: LibWally.Witness.WitnessType, pubKey: LibWally.ECCompressedPublicKey, signature: Foundation.Data, isDummy: Swift.Bool = false)
  public func createWallyStack() -> Swift.UnsafeMutablePointer<LibWally.wally_tx_witness_stack>
  public init(type: LibWally.Witness.WitnessType, pubKey: LibWally.ECCompressedPublicKey)
  public func signed(signature: Foundation.Data) -> LibWally.Witness
  public var script: LibWally.Script {
    get
  }
}
public protocol PSBTSigner : Swift.Hashable {
  var masterKey: LibWally.HDKey { get }
}
public struct UseInfo : Swift.Equatable {
  public let asset: LibWally.Asset
  public let network: LibWally.Network
  public init(asset: LibWally.Asset = .btc, network: LibWally.Network = .mainnet)
  public static func == (a: LibWally.UseInfo, b: LibWally.UseInfo) -> Swift.Bool
}
extension LibWally.UseInfo {
  public var coinType: Swift.UInt32 {
    get
  }
  public func accountDerivationPath(account: Swift.UInt32) -> LibWally.DerivationPath
}
extension LibWally.UseInfo {
  public var versionSH: Swift.UInt8 {
    get
  }
  public var versionPKH: Swift.UInt8 {
    get
  }
}
public struct BIP39 {
  public let mnemonic: Swift.String
  public let data: Foundation.Data
  public var words: [Swift.String] {
    get
  }
  public init?(mnemonic: Swift.String)
  public init?(words: [Swift.String])
  public init?(data: Foundation.Data)
  public init?(hex: Swift.String)
  public static var allWords: [Swift.String]
}
extension LibWally.BIP39 : Swift.Equatable {
  public static func == (lhs: LibWally.BIP39, rhs: LibWally.BIP39) -> Swift.Bool
}
extension LibWally.BIP39 : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LibWally.BIP39 {
  public struct Seed : Swift.Equatable, Swift.CustomStringConvertible {
    public init?(hex: Swift.String)
    public init(bip39: LibWally.BIP39, passphrase: Swift.String? = nil)
    public var description: Swift.String {
      get
    }
    public static func == (a: LibWally.BIP39.Seed, b: LibWally.BIP39.Seed) -> Swift.Bool
  }
}
public struct TxHash : Swift.Equatable {
  public let data: Foundation.Data
  public init?(_ data: Foundation.Data)
  public init?(hex: Swift.String)
  public var hex: Swift.String {
    get
  }
  public static func == (a: LibWally.TxHash, b: LibWally.TxHash) -> Swift.Bool
}
public struct TxInput {
  public let prevTx: LibWally.TxHash
  public let vout: Swift.UInt32
  public let sequence: Swift.UInt32
  public let amount: LibWally.Satoshi
  public var sig: LibWally.TxInput.Sig
  public let scriptPubKey: LibWally.ScriptPubKey
  public enum Sig {
    case scriptSig(LibWally.ScriptSig)
    case witness(LibWally.Witness)
  }
  public init(prevTx: LibWally.TxHash, vout: Swift.UInt32, sequence: Swift.UInt32 = 0xffffffff, amount: LibWally.Satoshi, sig: LibWally.TxInput.Sig, scriptPubKey: LibWally.ScriptPubKey)
  public func createWallyInput() -> LibWally.WallyTxInput
  public var isSigned: Swift.Bool {
    get
  }
}
extension LibWally.Bitcoin {
  open class Address : LibWally.AddressProtocol {
    final public let useInfo: LibWally.UseInfo
    final public let scriptPubKey: LibWally.ScriptPubKey
    final public let string: Swift.String
    public init?(string: Swift.String)
    public convenience init(hdKey: LibWally.HDKey, type: LibWally.Bitcoin.Address.AddressType)
    public init?(scriptPubKey: LibWally.ScriptPubKey, network: LibWally.Network)
    public enum AddressType {
      case payToPubKeyHash
      case payToScriptHashPayToWitnessPubKeyHash
      case payToWitnessPubKeyHash
      public static func == (a: LibWally.Bitcoin.Address.AddressType, b: LibWally.Bitcoin.Address.AddressType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    open var description: Swift.String {
      get
    }
    @objc deinit
  }
}
extension LibWally.Ethereum {
  open class Address : LibWally.AddressProtocol {
    final public let useInfo: LibWally.UseInfo
    final public let string: Swift.String
    public init?(string: Swift.String, network: LibWally.Network)
    public init(key: LibWally.ECKey, network: LibWally.Network)
    public convenience init(hdKey: LibWally.HDKey)
    open var description: Swift.String {
      get
    }
    public var shortString: Swift.String {
      get
    }
    @objc deinit
  }
}
public struct Script : Swift.Equatable {
  public let data: Foundation.Data
  public init(_ data: Foundation.Data)
  public init(ops: [LibWally.ScriptOperation])
  public init?(hex: Swift.String)
  public init?(asm: Swift.String)
  public var hex: Swift.String {
    get
  }
  public var operations: [LibWally.ScriptOperation]? {
    get
  }
  public var asm: Swift.String? {
    get
  }
  public static func == (a: LibWally.Script, b: LibWally.Script) -> Swift.Bool
}
extension LibWally.Script : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
final public class DescriptorLexer {
  public init(source: Swift.String)
  public static func debugLex(_ source: Swift.String) throws -> Swift.String
  @objc deinit
}
public struct ScriptSig {
  public let type: LibWally.ScriptSig.ScriptSigType
  public var signature: Foundation.Data?
  public enum ScriptSigType : Swift.Equatable {
    case payToPubKeyHash(LibWally.ECCompressedPublicKey)
    case payToScriptHashPayToWitnessPubKeyHash(LibWally.ECCompressedPublicKey)
    public static func == (a: LibWally.ScriptSig.ScriptSigType, b: LibWally.ScriptSig.ScriptSigType) -> Swift.Bool
  }
  public init(type: LibWally.ScriptSig.ScriptSigType)
  public enum ScriptSigPurpose {
    case signed
    case feeWorstCase
    public static func == (a: LibWally.ScriptSig.ScriptSigPurpose, b: LibWally.ScriptSig.ScriptSigPurpose) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func render(purpose: LibWally.ScriptSig.ScriptSigPurpose) -> LibWally.Script?
}
final public class SecureRandomNumberGenerator : Swift.RandomNumberGenerator {
  public init()
  public static var shared: LibWally.SecureRandomNumberGenerator
  final public func next() -> Swift.UInt64
  final public func data(count: Swift.Int) -> Foundation.Data
  @objc deinit
}
